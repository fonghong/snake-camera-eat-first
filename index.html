<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è²ªé£Ÿè›‡ï¼šç›¸æ©Ÿé£Ÿå…ˆ (Snake: Camera Eats First)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        
        /* Ensure the body takes up exactly the visible viewport height */
        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: #1a1a1a;
            color: #e5e5e5;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Dynamic Viewport Height for mobile browsers */
            width: 100vw;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Disable default touch actions */
            display: flex;
            flex-direction: column;
        }

        #gameCanvas {
            box-shadow: 0 0 20px rgba(0, 255, 100, 0.2);
            image-rendering: pixelated;
        }

        .pixel-btn {
            box-shadow: 4px 4px 0px 0px #000;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .pixel-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px 0px #000;
        }
        
        .level-btn.selected {
            background-color: #fbbf24;
            color: black;
            border-color: #fbbf24;
        }

        .d-pad-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        .d-pad-btn:active {
            background: rgba(0, 255, 100, 0.4);
            border-color: #00ff64;
        }

        .lang-switch {
            font-size: 0.8rem;
            border: 1px solid #666;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(0,0,0,0.5);
            cursor: pointer;
        }

        .hide-scroll::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body class="bg-[#1a1a1a]">

    <!-- 1. Header Area (Flex None - Fixed size) -->
    <div class="flex-none w-full px-4 pt-4 pb-2 flex justify-between items-start z-30">
        <div>
            <button id="langBtn" class="lang-switch mb-2 text-gray-300 font-sans" onclick="toggleLanguage()">EN / ä¸­</button>
            <h1 id="titleText" class="text-xl md:text-4xl text-green-400 font-bold drop-shadow-md leading-tight">è²ªé£Ÿè›‡ï¼šç›¸æ©Ÿé£Ÿå…ˆ</h1>
            <p class="text-xs md:text-sm text-gray-400 mt-1">Lv <span id="currentLevelDisplay">1</span></p>
        </div>
        <div class="text-right">
            <div id="scoreLabel" class="text-sm text-gray-400">SCORE</div>
            <div id="scoreEl" class="text-4xl font-bold text-white">0</div>
        </div>
    </div>

    <!-- 2. Game Area (Flex Grow - Takes remaining space) -->
    <!-- Added min-h-0 to allow flex child to shrink below content size if needed -->
    <div id="game-container" class="flex-1 w-full relative flex items-center justify-center min-h-0 p-2 overflow-hidden">
        <canvas id="gameCanvas" class="bg-gray-900 border-4 border-gray-700 rounded-lg max-w-full max-h-full"></canvas>
        
        <!-- Overlay is absolute relative to this container -->
        <div id="overlay" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 transition-opacity duration-300 overflow-y-auto">
            <div class="flex flex-col items-center justify-center min-h-full py-4"> <!-- Inner container for scrolling -->
                <h2 id="overlayTitle" class="text-5xl text-green-400 mb-2 animate-pulse text-center px-2">PRESS START</h2>
                <p id="overlaySub" class="text-gray-400 text-sm mb-6 text-center leading-relaxed">
                    é›»è…¦ï¼šæ–¹å‘éµæ§åˆ¶<br>æ‰‹æ©Ÿï¼šæ»‘å‹•è¢å¹• æˆ– é»æ“Šè™›æ“¬éµ
                </p>
                
                <div class="bg-gray-800 p-5 rounded-lg border-2 border-gray-600 mb-4 w-11/12 max-w-sm">
                    <div class="mb-5">
                        <p id="levelLabel" class="text-sm text-gray-400 mb-2 text-center">é¸æ“‡é€Ÿåº¦ (Speed)</p>
                        <div class="flex justify-between gap-2" id="levelSelector">
                            <button class="pixel-btn level-btn flex-1 py-2 border border-gray-500 rounded text-xs selected" onclick="selectLevel(1)">1</button>
                            <button class="pixel-btn level-btn flex-1 py-2 border border-gray-500 rounded text-xs" onclick="selectLevel(2)">2</button>
                            <button class="pixel-btn level-btn flex-1 py-2 border border-gray-500 rounded text-xs" onclick="selectLevel(3)">3</button>
                            <button class="pixel-btn level-btn flex-1 py-2 border border-gray-500 rounded text-xs" onclick="selectLevel(4)">4</button>
                            <button class="pixel-btn level-btn flex-1 py-2 border border-gray-500 rounded text-xs" onclick="selectLevel(5)">5</button>
                        </div>
                    </div>
                    <div class="border-t border-gray-600 my-4"></div>
                    <h3 id="skinTitle" class="text-lg text-yellow-400 mb-3 text-center">è‡ªå®šç¾©çš®è†š</h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <span id="snakeLabel" class="text-sm">ğŸ è›‡èº«:</span>
                            <label class="pixel-btn bg-green-600 hover:bg-green-500 text-white text-xs py-2 px-3 rounded cursor-pointer flex items-center justify-center min-w-[80px]">
                                <span class="upload-text">ä¸Šå‚³åœ–ç‰‡</span>
                                <input type="file" accept="image/*" class="hidden" onchange="handleImageUpload(event, 'snake')">
                            </label>
                            <div id="preview-snake" class="w-10 h-10 bg-green-500 border border-white ml-2 bg-cover bg-center rounded-sm flex-shrink-0"></div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span id="foodLabel" class="text-sm">ğŸ é£Ÿç‰©:</span>
                            <label class="pixel-btn bg-red-600 hover:bg-red-500 text-white text-xs py-2 px-3 rounded cursor-pointer flex items-center justify-center min-w-[80px]">
                                <span class="upload-text">ä¸Šå‚³åœ–ç‰‡</span>
                                <input type="file" accept="image/*" class="hidden" onchange="handleImageUpload(event, 'food')">
                            </label>
                            <div id="preview-food" class="w-10 h-10 bg-red-500 border border-white ml-2 bg-cover bg-center rounded-sm flex-shrink-0"></div>
                        </div>
                    </div>
                </div>

                <button id="startBtn" class="pixel-btn bg-yellow-400 text-black text-xl font-bold py-3 px-10 rounded mb-4 shadow-lg hover:scale-105 transition-transform">
                    é–‹å§‹éŠæˆ²
                </button>
            </div>
        </div>
    </div>

    <!-- 3. Virtual Controls (Flex None - Fixed size) -->
    <!-- Added 'hidden' class by default, removed manually in JS when game starts -->
    <div id="virtual-controls" class="flex-none hidden w-full justify-center items-center pb-8 pt-2 md:hidden z-30 bg-[#1a1a1a]">
        <div class="grid grid-cols-3 gap-3">
            <div></div>
            <button class="d-pad-btn w-16 h-16" ontouchstart="handleVirtualInput('ArrowUp')" onmousedown="handleVirtualInput('ArrowUp')">â–²</button>
            <div></div>
            <button class="d-pad-btn w-16 h-16" ontouchstart="handleVirtualInput('ArrowLeft')" onmousedown="handleVirtualInput('ArrowLeft')">â—€</button>
            <button class="d-pad-btn w-16 h-16" ontouchstart="handleVirtualInput('ArrowDown')" onmousedown="handleVirtualInput('ArrowDown')">â–¼</button>
            <button class="d-pad-btn w-16 h-16" ontouchstart="handleVirtualInput('ArrowRight')" onmousedown="handleVirtualInput('ArrowRight')">â–¶</button>
        </div>
    </div>

    <script>
        // --- Localization Config ---
        const translations = {
            zh: {
                title: "è²ªé£Ÿè›‡ï¼šç›¸æ©Ÿé£Ÿå…ˆ",
                score: "åˆ†æ•¸",
                pressStart: "æŒ‰æ­¤é–‹å§‹",
                instructions: "é›»è…¦ï¼šæ–¹å‘éµæ§åˆ¶<br>æ‰‹æ©Ÿï¼šæ»‘å‹•è¢å¹• æˆ– é»æ“Šè™›æ“¬éµ",
                speed: "é¸æ“‡é€Ÿåº¦ (Speed)",
                skin: "è‡ªå®šç¾©çš®è†š",
                body: "ğŸ è›‡èº«:",
                food: "ğŸ é£Ÿç‰©:",
                upload: "ä¸Šå‚³åœ–ç‰‡",
                start: "é–‹å§‹éŠæˆ²",
                retry: "å†ä¾†ä¸€æ¬¡",
                gameover: "éŠæˆ²çµæŸ"
            },
            en: {
                title: "Snake: Camera Eats First",
                score: "SCORE",
                pressStart: "PRESS START",
                instructions: "Desktop: Arrow Keys<br>Mobile: Swipe or use D-Pad",
                speed: "Select Speed",
                skin: "Customize Skins",
                body: "ğŸ Body:",
                food: "ğŸ Food:",
                upload: "Upload Img",
                start: "START GAME",
                retry: "PLAY AGAIN",
                gameover: "GAME OVER"
            }
        };

        let currentLang = 'zh';
        let isGameOverState = false;

        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            updateUIText();
        }

        function updateUIText() {
            const t = translations[currentLang];
            document.getElementById('titleText').textContent = t.title;
            document.getElementById('scoreLabel').textContent = t.score;
            document.getElementById('overlaySub').innerHTML = t.instructions;
            document.getElementById('levelLabel').textContent = t.speed;
            document.getElementById('skinTitle').textContent = t.skin;
            document.getElementById('snakeLabel').textContent = t.body;
            document.getElementById('foodLabel').textContent = t.food;
            document.querySelectorAll('.upload-text').forEach(el => el.textContent = t.upload);

            const overlayTitle = document.getElementById('overlayTitle');
            const startBtn = document.getElementById('startBtn');

            if (isGameOverState) {
                overlayTitle.textContent = t.gameover;
                startBtn.textContent = t.retry;
            } else {
                overlayTitle.textContent = t.pressStart;
                startBtn.textContent = t.start;
            }
        }

        // --- Game Config ---
        const canvas = document.getElementById('gameCanvas');
        const container = document.getElementById('game-container'); // Get container
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreEl');
        const currentLevelDisplay = document.getElementById('currentLevelDisplay');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const startBtn = document.getElementById('startBtn');
        const previewSnake = document.getElementById('preview-snake');
        const previewFood = document.getElementById('preview-food');
        const virtualControls = document.getElementById('virtual-controls'); // Controls ref

        let gridSize = 30; 
        let tileCountX = 20;
        let tileCountY = 20;
        let snake = [];
        let food = { x: 10, y: 10 };
        let dx = 0;
        let dy = 0;
        let nextDx = 0;
        let nextDy = 0;
        let score = 0;
        let gameLoopId;
        let isGameRunning = false;
        
        let currentLevel = 1;
        const levelSpeeds = {
            1: 250, 2: 180, 3: 130, 4: 90, 5: 60
        };

        const assets = { snake: null, food: null };

        window.selectLevel = (lv) => {
            currentLevel = lv;
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.innerText) === lv) btn.classList.add('selected');
            });
        };

        // --- NEW Resizing Logic ---
        function resizeCanvas() {
            // Get the actual available space in the middle container
            // This is safer than window.innerHeight - constant
            const maxWidth = container.clientWidth - 10; 
            const maxHeight = container.clientHeight - 10;
            
            // Calculate cols/rows based on available space
            const cols = Math.floor(maxWidth / gridSize);
            const rows = Math.floor(maxHeight / gridSize);

            // Set minimum size
            tileCountX = Math.max(10, cols);
            tileCountY = Math.max(10, rows);
            
            canvas.width = tileCountX * gridSize;
            canvas.height = tileCountY * gridSize;

            if (!isGameRunning) {
                if (snake.length > 0) drawGame();
                else {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
        }

        window.addEventListener('resize', resizeCanvas);
        // We delay slightly to let layout settle on mobile
        setTimeout(resizeCanvas, 100);

        function handleImageUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    const size = 128; 
                    tempCanvas.width = size;
                    tempCanvas.height = size;
                    const tCtx = tempCanvas.getContext('2d');
                    const minDim = Math.min(img.width, img.height);
                    const sx = (img.width - minDim) / 2;
                    const sy = (img.height - minDim) / 2;
                    tCtx.drawImage(img, sx, sy, minDim, minDim, 0, 0, size, size);
                    assets[type] = tempCanvas;
                    const previewEl = type === 'snake' ? previewSnake : previewFood;
                    previewEl.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                    previewEl.textContent = ''; 
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initGame() {
            // SHOW controls when game starts (Remove 'hidden', add 'flex')
            virtualControls.classList.remove('hidden');
            virtualControls.classList.add('flex');
            
            // Wait a tick for DOM to update layout, then resize canvas to fit new space
            setTimeout(() => {
                resizeCanvas(); 
                
                snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
                score = 0;
                scoreEl.innerText = score;
                currentLevelDisplay.innerText = currentLevel;
                dx = 0; dy = 0; nextDx = 0; nextDy = 0;
                placeFood();
                isGameRunning = true;
                isGameOverState = false; 
                
                overlay.style.opacity = '0';
                setTimeout(() => overlay.style.display = 'none', 300);
                
                if (gameLoopId) clearInterval(gameLoopId);
                const speed = levelSpeeds[currentLevel];
                gameLoopId = setInterval(gameStep, speed);
                drawGame();
            }, 50);
        }

        function gameStep() {
            if (nextDx !== 0 || nextDy !== 0) {
                dx = nextDx; dy = nextDy;
            }
            if (dx === 0 && dy === 0) return;
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                gameOver(); return;
            }
            for (let part of snake) {
                if (head.x === part.x && head.y === part.y) {
                    gameOver(); return;
                }
            }
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++; scoreEl.innerText = score; placeFood();
            } else {
                snake.pop();
            }
            drawGame();
        }

        function placeFood() {
            let valid = false;
            while (!valid) {
                food.x = Math.floor(Math.random() * tileCountX);
                food.y = Math.floor(Math.random() * tileCountY);
                valid = true;
                for (let part of snake) {
                    if (part.x === food.x && part.y === food.y) {
                        valid = false; break;
                    }
                }
            }
        }

        function drawGame() {
            ctx.fillStyle = '#111'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for(let i=0; i<=tileCountX; i++) {
                ctx.beginPath(); ctx.moveTo(i*gridSize, 0); ctx.lineTo(i*gridSize, canvas.height); ctx.stroke();
            }
            for(let i=0; i<=tileCountY; i++) {
                ctx.beginPath(); ctx.moveTo(0, i*gridSize); ctx.lineTo(canvas.width, i*gridSize); ctx.stroke();
            }

            if (assets.food) {
                ctx.drawImage(assets.food, food.x * gridSize, food.y * gridSize, gridSize, gridSize);
            } else {
                ctx.fillStyle = '#ef4444';
                const pad = 2;
                ctx.roundRect(food.x * gridSize + pad, food.y * gridSize + pad, gridSize - (pad*2), gridSize - (pad*2), 4);
                ctx.fill();
            }

            snake.forEach((part, index) => {
                if (assets.snake) {
                    ctx.drawImage(assets.snake, part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    if (index === 0) {
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                        ctx.strokeRect(part.x * gridSize, part.y * gridSize, gridSize, gridSize);
                    }
                } else {
                    ctx.fillStyle = index === 0 ? '#4ade80' : '#22c55e';
                    const pad = 1;
                    ctx.beginPath();
                    ctx.roundRect(part.x * gridSize + pad, part.y * gridSize + pad, gridSize - (pad*2), gridSize - (pad*2), 4);
                    ctx.fill();
                }
            });
        }

        function gameOver() {
            isGameRunning = false;
            isGameOverState = true;
            clearInterval(gameLoopId);
            
            // HIDE controls on game over to give space for menu
            virtualControls.classList.add('hidden');
            virtualControls.classList.remove('flex');
            // Resize canvas back to full height for background effect
            setTimeout(resizeCanvas, 50);

            updateUIText(); 
            overlayTitle.classList.add('text-red-500');
            overlayTitle.classList.remove('text-green-400');
            overlay.style.display = 'flex';
            setTimeout(() => overlay.style.opacity = '1', 10);
        }

        function handleInput(key) {
            if (key === 'ArrowUp' && dy === 1) return;
            if (key === 'ArrowDown' && dy === -1) return;
            if (key === 'ArrowLeft' && dx === 1) return;
            if (key === 'ArrowRight' && dx === -1) return;
            switch(key) {
                case 'ArrowUp': nextDx = 0; nextDy = -1; break;
                case 'ArrowDown': nextDx = 0; nextDy = 1; break;
                case 'ArrowLeft': nextDx = -1; nextDy = 0; break;
                case 'ArrowRight': nextDx = 1; nextDy = 0; break;
            }
            if (dx === 0 && dy === 0 && isGameRunning) {
                dx = nextDx; dy = nextDy;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault(); handleInput(e.key);
            }
        });

        window.handleVirtualInput = (key) => {
            if (window.navigator.vibrate) window.navigator.vibrate(10);
            handleInput(key);
        };

        let touchStartX = 0; let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            if(e.target.closest('.d-pad-btn') || e.target.closest('button')) return;
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;
            if(e.target.closest('.d-pad-btn') || e.target.closest('button')) return;
            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
        }, {passive: false});

        function handleSwipe(sx, sy, ex, ey) {
            let xDiff = ex - sx; let yDiff = ey - sy;
            if (Math.abs(xDiff) < 30 && Math.abs(yDiff) < 30) return; 
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                handleInput(xDiff > 0 ? 'ArrowRight' : 'ArrowLeft');
            } else {
                handleInput(yDiff > 0 ? 'ArrowDown' : 'ArrowUp');
            }
        }

        startBtn.addEventListener('click', () => {
            overlayTitle.classList.remove('text-red-500');
            overlayTitle.classList.add('text-green-400');
            initGame();
        });

        updateUIText();
        setTimeout(resizeCanvas, 0); 
    </script>
</body>
</html>


